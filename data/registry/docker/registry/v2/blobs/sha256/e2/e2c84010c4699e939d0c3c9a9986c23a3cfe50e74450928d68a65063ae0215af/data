#!/usr/bin/env python3
import os, time, json
from proxmoxer import ProxmoxAPI
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def env(name, default=None, required=False):
    v = os.getenv(name, default)
    if required and (v is None or v == ""):
        raise SystemExit(f"Missing env: {name}")
    return v

api_url   = env("PROXMOX_API_URL", required=True)
user      = env("PROXMOX_USER", required=True)
password  = env("PROXMOX_PASSWORD", required=True)
verify    = (env("PROXMOX_VERIFY_SSL", "false").lower() != "false")

node      = env("PROXMOX_NODE", "cecpa")
datastore = env("PROXMOX_DATASTORE", "local-lvm")

template_vmid = int(env("TEMPLATE_VMID", "2210"))      # << default 2200
cores         = int(env("VM_CORES", "2"))
memory_mb     = int(env("VM_MEMORY_MB", "2048"))
net_bridge    = env("NET_BRIDGE", "vmbr0")
vlan_tag      = env("NET_VLAN_TAG", "")
clone_mode    = env("CLONE_MODE", "linked").lower()

range_start   = int(env("VMID_RANGE_START", "2600"))
range_end     = int(env("VMID_RANGE_END", "2700"))

host = api_url.split("/api2/json")[0].replace("https://","").replace("http://","").strip("/")
px = ProxmoxAPI(host=host, user=user, password=password, verify_ssl=verify)

def upid_of(resp):
    if isinstance(resp, str): return resp
    if isinstance(resp, dict): return resp.get("data") or resp.get("upid") or next(iter(resp.values()), None)
    return None

def wait_task(upid):
    if not upid: raise SystemExit("UPID invÃ¡lido ao iniciar tarefa no Proxmox")
    while True:
        s = px.nodes(node).tasks(upid).status.get()
        if s.get("status") == "stopped":
            if s.get("exitstatus") == "OK": return
            raise SystemExit(f"Task failed: {s}")
        time.sleep(1)

def nextid_in_range(start: int, end: int) -> int:
    used = {int(v["vmid"]) for v in px.cluster.resources.get(type="vm")}
    for vid in range(start, end + 1):
        if vid not in used:
            return vid
    raise SystemExit(f"Nenhum VMID livre entre {start}-{end}")

vmid = nextid_in_range(range_start, range_end)

if clone_mode == "linked":
    clone_resp = px.nodes(node).qemu(template_vmid).clone.post(
        newid=vmid, full=0, target=node
    )
else:
    clone_resp = px.nodes(node).qemu(template_vmid).clone.post(
        newid=vmid, full=1, target=node, storage=datastore
    )
wait_task(upid_of(clone_resp))

cfg = dict(
    cores=cores,
    memory=memory_mb,
    agent=1,
    ciuser="ctf",
    ipconfig0="ip=dhcp",
)
if vlan_tag:
    cfg["net0"] = f"e1000,bridge={net_bridge},tag={vlan_tag}"

px.nodes(node).qemu(vmid).config.post(**cfg)

start_resp = px.nodes(node).qemu(vmid).status.start.post()
wait_task(upid_of(start_resp))

def get_ip(timeout=240):
    t0 = time.time()
    while time.time() - t0 < timeout:
        try:
            res = px.nodes(node).qemu(vmid).agent("network-get-interfaces").get()
            for itf in res.get("result", []):
                for addr in itf.get("ip-addresses", []):
                    ip = addr.get("ip-address")
                    if ip and ":" not in ip and not ip.startswith("127."):
                        return ip
        except Exception:
            pass
        time.sleep(2)
    return None

ip = get_ip()
if not ip:
    raise SystemExit("Falha ao obter IP via qemu-guest-agent (verifique cloud-init/agent/DHCP).")

print(json.dumps({"ip": ip}))
