#!/usr/bin/env python3
import os, json, time, pathlib, sys
from proxmoxer import ProxmoxAPI
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# ---------- utils ----------
def env(name, default=None, required=False):
    v = os.getenv(name, default)
    if required and (v is None or v == ""):
        raise SystemExit(f"Missing env: {name}")
    return v

def to_int(x):
    if x is None: return None
    try: return int(str(x).strip())
    except Exception: return None

def parse_json(s):
    if not s: return None
    try: return json.loads(s)
    except Exception: return None

def load_json_env(name):
    return parse_json(os.getenv(name))

def extract_ip(obj):
    """Extrai IP de formatos comuns: {'ip': 'A.B.C.D'} ou connectionInfo='{\"ip\":\"...\"}'."""
    if obj is None: return None
    if isinstance(obj, dict):
        for k in ("ip", "address"):
            v = obj.get(k)
            if isinstance(v, str) and v: return v
        for k in ("connectionInfo", "connection_info"):
            v = obj.get(k)
            if isinstance(v, str) and v.strip().startswith("{"):
                o = parse_json(v)
                if o:
                    for kk in ("ip", "address"):
                        vv = o.get(kk)
                        if isinstance(vv, str) and vv: return vv
    if isinstance(obj, str):
        s = obj.strip()
        if s.startswith("{"):
            o = parse_json(s)
            if o:
                for kk in ("ip","address"):
                    vv = o.get(kk)
                    if isinstance(vv, str) and vv: return vv
        else:
            # último recurso: se parecer IPv4
            parts = s.split(".")
            if len(parts)==4 and all(p.isdigit() and 0<=int(p)<=255 for p in parts): return s
    return None

# ---------- fontes de VMID/IP ----------
def load_vmid_and_ip_from_envs_and_outputs_local():
    """VMID/IP a partir de: VMID, OUTPUTS_JSON, PULUMI_COMMAND_STDOUT, outputs.json (local do PROJ_DIR)."""
    vmid = to_int(os.getenv("VMID"))
    ip = os.getenv("IP") or None

    if vmid is None:
        o = load_json_env("OUTPUTS_JSON")
        if o:
            vmid = to_int(o.get("vmid") or o.get("VMID"))
            ip = extract_ip(o) or ip

    if vmid is None or not ip:
        o = load_json_env("PULUMI_COMMAND_STDOUT")
        if o:
            if vmid is None:
                vmid = to_int(o.get("vmid") or o.get("VMID"))
            ip = extract_ip(o) or ip

    if vmid is None or not ip:
        try:
            here = pathlib.Path(__file__).resolve().parent
            o = json.loads((here / "outputs.json").read_text(encoding="utf-8"))
            if vmid is None:
                vmid = to_int(o.get("vmid") or o.get("VMID"))
            ip = extract_ip(o) or ip
        except Exception:
            pass

    return vmid, ip

def load_ip_from_instance_info():
    """
    Lê o IP do connection_info do info.json da instância:
    <CHALL_DIR>/instance/<IDENTITY>/info.json
    onde CHALL_DIR = parent(PROJ_DIR)
    PROJ_DIR = diretório deste destroy.py.
    """
    try:
        identity = os.getenv("IDENTITY", "").strip()
        if not identity:
            return None
        here = pathlib.Path(__file__).resolve().parent          # PROJ_DIR
        chall_dir = here.parent                                 # CHALL_DIR
        info_path = chall_dir / "instance" / identity / "info.json"
        if not info_path.exists():
            return None
        j = json.loads(info_path.read_text(encoding="utf-8"))
        # raiz: connection_info pode ser string JSON
        ip = extract_ip(j.get("connection_info"))
        if ip:
            return ip
        # fallback: dentro do primeiro recurso stack
        st = j.get("state", {})
        for r in st.get("resources", []):
            if r.get("type") == "pulumi:pulumi:Stack":
                out = r.get("outputs", {}) or {}
                ip = extract_ip(out.get("connection_info"))
                if ip:
                    return ip
        return None
    except Exception:
        return None

# ---------- Proxmox helpers ----------
def list_ipv4_from_agent(px, node, vmid):
    try:
        res = px.nodes(node).qemu(vmid).agent("network-get-interfaces").get()
        ips = []
        for itf in res.get("result", []):
            for addr in itf.get("ip-addresses", []):
                ip = addr.get("ip-address")
                if ip and ":" not in ip and not ip.startswith("127."):
                    ips.append(ip)
        return ips
    except Exception:
        return []

def discover_vmid_by_ip(px, node, ip, start=None, end=None):
    """Procura VM 'running' cujo Guest Agent reporte exatamente esse IP dentro do node/faixa."""
    if not ip:
        return None
    try:
        vms = px.cluster.resources.get(type="vm")
    except Exception:
        return None
    cands = []
    for v in vms:
        try:
            if v.get("node") != node: continue
            if v.get("status") != "running": continue
            vmid = to_int(v.get("vmid"))
            if vmid is None: continue
            if start and end and not (start <= vmid <= end): continue
            ips = list_ipv4_from_agent(px, node, vmid)
            if ip in ips:
                cands.append(vmid)
        except Exception:
            continue
    return cands[0] if len(cands) == 1 else None

def wait_task(px, node, upid, timeout=180):
    if not upid: return
    t0 = time.time()
    while time.time() - t0 < timeout:
        try:
            s = px.nodes(node).tasks(upid).status.get()
            if s.get("status") == "stopped":
                return
        except Exception:
            break
        time.sleep(1)

# ---------- main ----------
def main():
    # Credenciais/infra
    api_url   = env("PROXMOX_API_URL", required=True)
    user      = env("PROXMOX_USER", required=True)
    password  = env("PROXMOX_PASSWORD", required=True)
    verify    = (env("PROXMOX_VERIFY_SSL", "false").lower() != "false")
    node      = env("PROXMOX_NODE", "cecpa")

    start = to_int(os.getenv("VMID_RANGE_START"))
    end   = to_int(os.getenv("VMID_RANGE_END"))

    host = api_url.split("/api2/json")[0].replace("https://","").replace("http://","").strip("/")
    px = ProxmoxAPI(host=host, user=user, password=password, verify_ssl=verify)

    vmid, ip = load_vmid_and_ip_from_envs_and_outputs_local()

    # Sem vmid? busca IP do info.json da instância (determinístico)
    if vmid is None and not ip:
        ip = load_ip_from_instance_info()

    # Com IP, tenta descobrir VMID pela consulta ao Guest Agent
    if vmid is None and ip:
        vmid = discover_vmid_by_ip(px, node, ip, start, end)

    # Idempotente/seguro: sem vmid => não remove nada, mas não quebra o fluxo
    if vmid is None:
        print(json.dumps({"deleted": True, "vmid": None, "note": "no vmid; could not map by IP; skipped"}))
        sys.exit(0)

    # Para VM
    try:
        px.nodes(node).qemu(vmid).status.stop.post()
    except Exception:
        pass

    # Aguarda parar
    t0 = time.time()
    while time.time() - t0 < 120:
        try:
            st = px.nodes(node).qemu(vmid).status.current.get()
            if st.get("status") != "running":
                break
        except Exception:
            break
        time.sleep(2)

    # Exclui VM
    try:
        up = px.nodes(node).qemu(vmid).delete()
        if isinstance(up, (str, dict)):
            upid = up if isinstance(up, str) else (up.get("data") or up.get("upid"))
            wait_task(px, node, upid, timeout=120)
    except Exception:
        pass

    print(json.dumps({"deleted": True, "vmid": vmid, "by": "vmid" if vmid else "ip"}))
    sys.exit(0)

if __name__ == "__main__":
    main()
