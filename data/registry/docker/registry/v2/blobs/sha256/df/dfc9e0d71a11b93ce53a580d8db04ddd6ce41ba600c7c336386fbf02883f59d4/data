#!/usr/bin/env python3
import os, time, json, pathlib
from proxmoxer import ProxmoxAPI
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def env(name, default=None, required=False):
    v = os.getenv(name, default)
    if required and (v is None or v == ""):
        raise SystemExit(f"Missing env: {name}")
    return v

# --- Infra obrigatória ---
api_url   = env("PROXMOX_API_URL", required=True)
user      = env("PROXMOX_USER", required=True)
password  = env("PROXMOX_PASSWORD", required=True)
verify    = (env("PROXMOX_VERIFY_SSL", "false").lower() != "false")
node      = env("PROXMOX_NODE", "cecpa")
datastore = env("PROXMOX_DATASTORE", "local-lvm")

# --- Defaults (range global 2200–2300) ---
template_vmid = int(env("TEMPLATE_VMID", "2200"))
cores         = int(env("VM_CORES", "2"))
memory_mb     = int(env("VM_MEMORY_MB", "2048"))
net_bridge    = env("NET_BRIDGE", "vmbr0")
vlan_tag      = env("NET_VLAN_TAG", "")
clone_mode    = env("CLONE_MODE", "linked").lower()

range_start   = int(env("VMID_RANGE_START", "2200"))
range_end     = int(env("VMID_RANGE_END", "2300"))

# --- Conexão Proxmox ---
host = api_url.split("/api2/json")[0].replace("https://","").replace("http://","").strip("/")
px = ProxmoxAPI(host=host, user=user, password=password, verify_ssl=verify)

def upid_of(resp):
    if isinstance(resp, str): return resp
    if isinstance(resp, dict): return resp.get("data") or resp.get("upid") or next(iter(resp.values()), None)
    return None

def wait_task(upid):
    if not upid: raise SystemExit("UPID inválido ao iniciar tarefa no Proxmox")
    while True:
        s = px.nodes(node).tasks(upid).status.get()
        if s.get("status") == "stopped":
            if s.get("exitstatus") == "OK": return
            raise SystemExit(f"Task failed: {s}")
        time.sleep(1)

def nextid_in_range(start: int, end: int) -> int:
    used = {int(v["vmid"]) for v in px.cluster.resources.get(type="vm")}
    used.add(template_vmid)
    for vid in range(start, end + 1):
        if vid not in used:
            return vid
    raise SystemExit(f"Nenhum VMID livre entre {start}-{end}")

vmid = nextid_in_range(range_start, range_end)

# --- Clone com fallback linked→full quando necessário ---
def do_clone(mode):
    if mode == "linked":
        return px.nodes(node).qemu(template_vmid).clone.post(
            newid=vmid, full=0, target=node
        )
    else:
        return px.nodes(node).qemu(template_vmid).clone.post(
            newid=vmid, full=1, target=node, storage=datastore
        )

try:
    clone_resp = do_clone(clone_mode)
except Exception as e:
    msg = str(e).lower()
    if "linked clone feature is not supported" in msg:
        clone_mode = "full"
        clone_resp = do_clone(clone_mode)
    else:
        raise
wait_task(upid_of(clone_resp))

# --- Config mínima ---
cfg = dict(
    cores=cores,
    memory=memory_mb,
    agent=1,
    ciuser="ctf",
    ipconfig0="ip=dhcp",
)
if vlan_tag:
    cfg["net0"] = f"e1000,bridge={net_bridge},tag={vlan_tag}"
px.nodes(node).qemu(vmid).config.post(**cfg)

# --- Liga VM ---
start_resp = px.nodes(node).qemu(vmid).status.start.post()
wait_task(upid_of(start_resp))

# --- IP via guest-agent ---
def get_ip(timeout=240):
    t0 = time.time()
    while time.time() - t0 < timeout:
        try:
            res = px.nodes(node).qemu(vmid).agent("network-get-interfaces").get()
            for itf in res.get("result", []):
                for addr in itf.get("ip-addresses", []):
                    ip = addr.get("ip-address")
                    if ip and ":" not in ip and not ip.startswith("127."):
                        return ip
        except Exception:
            pass
        time.sleep(2)
    return None

ip = get_ip()
if not ip:
    raise SystemExit("Falha ao obter IP via qemu-guest-agent (verifique cloud-init/agent/DHCP).")

# --- Persistência de outputs (para Destroy/Restart) ---
out = {"vmid": vmid, "ip": ip}
here = pathlib.Path(__file__).resolve().parent
try:
    (here / "outputs.json").write_text(json.dumps(out), encoding="utf-8")
except Exception:
    pass  # best effort

# CLI/smoke: emite JSON completo (vmid + ip)
print(json.dumps(out))
